\apendice{Especificación de diseño}

\section{Introducción}\label{diseño}
En este apéndice se recoge el diseño de las interfaces, como se resolvieron los requisitos funcionales anteriormente expuestos~\pageref{requisitos}, el manejo de los datos o la estructura de los mismos.

\section{Diseño de datos}
En el tratamiento de los datos, se ha optado por hacerlo de dos formas diferentes, esto es debido, a que se necesita persistencia local y externa. Dependiendo de eso, tenemos dos diseños de datos diferentes.

\begin{itemize}
	\item \textbf{FireStore:} es la base de datos integrada en Firestore. Esta no sigue el modelo clásico, ya que es noSQL~\cite{wiki:nosql}, es decir, al igual que mongoDB~\cite{wiki:mongodb}, esta se gestiona mediante ficheros \emph{.json}. A diferencia SGBDR (Sistema gestor de bases de datos relacionales), la manera de trabajar de Firestore, es mediante un modelos no relacionales. Esta fue usada para la persistencia externa de datos. Como se puede ver en la siguiente imagen~\ref{fig:firestore} de la consola de Firebase:
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{disenio/firestore.jpg}
		\caption{Base de datos en firestore}\label{fig:firestore}
	\end{figure}

	\item\label{sqlflite} \textbf{Sqlflite:} esta base de datos si que sigue el modelo tradicional del SGBDR. En mi caso fue necesario usar este paquete~\cite{package:sqlflite}, que internamente funciona con sqlite. Usado para almacenar datos en forma local, ya que no era necesario que los datos salieran del terminal. Una de las cosas a tener en cuenta de esto, es que si el usuario borra la caché de la aplicación o la desinstala se borran los ficheros correspondientes. Esto no debe de ser problema, ya que solo queremos almacenar ciertos valores.
	
\end{itemize}

\subsection{Diagrama entidad relación}
\begin{itemize}
	\item \textbf{FireStore:} la distribución en la base de datos es mediante colecciones, ver imagen~\ref{fig:diagramfirestore}. Como ejemplo podemos tener la colección para almacenar los datos del ranking, y para cada una de las entradas del ranking un fichero \emph{.josn} que haga referencia a los datos de cada usuario. Aunque esta no siga el modelo relacional, si que se podría implementar un diagrama entidad-relación, pero no se hace, porque es similar a tener dos tablas (colecciones en este caso) en la base de datos y que no tiene relación entre sí.
	
	\begin{figure}[H]
		\centering
		\includegraphics[height=0.9\textwidth]{disenio/diagramafirestore.jpg}
		\caption{Diagrama BD firestore}\label{fig:diagramfirestore}
	\end{figure}

	Una vez sabemos como es el funcionamiento de la base de datos noSQL, las dos colecciones necesarias para la aplicación fueron:
	
	\begin{itemize}
		\item \textbf{ranking:} se encarga de almacenar la mejor puntuación de cada uno de los jugadores del snake~\ref{fig:rankingexample}. Para distinguir cada uno de los documentos, se usa como clave primaria el correo del usuario, que también será el nombre que identifique a cada uno de estos ficheros.
		
		Las variables que almacena son: nombre(String), imagenUrl(String) y puntuación(int). 
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{disenio/rankingexample.jpg}
			\caption{Contenido json de rankinig}\label{fig:rankingexample}
		\end{figure}
	
		\item \textbf{cuatrorows:} esta colección guarda cada una de las partidas online del juego cuatro en raya~\ref{fig:cuatrorowsexample}. Los nombres de los documentos se generan de manera única en la base de datos, por lo que no puede haber dos partidas iguales.
		
		Por lo que la \emph{key} compartida durante el juego es la misma que el nombre del documento, dentro de esta colección. Los campos que tiene este documentos son muchos y variados, pero los más destacados son: 
		
		\begin{itemize}
			\item Posición de cada una de las fichas, de tipo String, y los valores que toma son Y, R o \emph{null}, dependiendo de la ficha que se encuentre en la celda.
			\item Datos de los jugadores, tanto como para el que crea la partida como el que recibe la invitación, estos son: nombre, imagenUrl, correos ... Todos de tipo String.
			\item Flags para controlar si se producen ciertos eventos, como puede ser el final de la partida, si se ha mostrado el mensaje, lanzamiento de la moneda para el sorteo de quien inicia o el mensaje escrito por cada uno de los jugadores. Todas ellas son de tipo String, exceptuando las que puedan tomar valores de verdadero o falso.
		\end{itemize}
	
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{disenio/cuatrorowsexample.jpg}
			\caption{Contenido json de cuatorows}\label{fig:cuatrorowsexample}
		\end{figure}
	\end{itemize}
	
	\item \textbf{Sqlflite:} usada para la persistencia interna de datos. No tiene diagrama de entidad relación ya que solo consta de una tabla. Como se puede ver en la imagen~\ref{fig:tablasqlflite}, este método se encarga de crear el recurso de la tabla, en el caso de que no existan, (cuando se instala la aplicación en el terminal).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{disenio/tablasqlflite.png}
		\caption{Método para crear la tabla en la base de datos local}\label{fig:tablasqlflite}
	\end{figure}

	Cada uno de los campos de esta tabla significan:
	\begin{itemize}
		\item \textbf{id:} identificador de tipo entero autoincrementable. Se usa internamente nada más, al final estas variables que almacena, se van a identificar por el nombre.
		\item \textbf{value:} valor que toma esta variable de tipo entero, puede ser 0 o 1, para las de tipo \emph{bool} o valores numéricos. Se hace así con el fin de abarcar estos dos tipos de datos.
		\item \textbf{nombre:} es de tipo String, usada para reconocer a cada una de las variables en la tabla.
		\item \textbf{createdTime:} fecha en la que se añade a la tabla una nueva variable. El tipo de dato que almacena es \emph{datetime}.
	\end{itemize}

	Un ejemplo de uso, lo podemos encontrar dentro de la aplicación en el apartado de \emph{settings}, donde cada vez que se cambia el valor de un \emph{slider} se actualiza en la base de datos. Esto se hace para que cuando el usuario vuelva a la aplicación, la configuración de la última vez que estuvo se siga manteniendo.
	
\end{itemize}

Otra de las formas en las que se almacenan los datos es mediante un fichero en local. Esto solo es usado para la configuración del menú, ya que cada vez que se crea el \emph{Widget} del menú lateral, lee el \emph{.json} para sacar los datos necesarios. Esta lógica de negocio se podría haber usado de la misma forma para solventar el problema de sqlflite~\pageref{sqlflite}.

\section{Diseño procedimental}
Para la gran mayoría de procesos importantes se han hecho diagramas de flujo, con el fin de resolver y comprender algunas de las lógicas de negocio más importantes. Un ejemplo de esto es el siguiente diagrama~\ref{fig:snakediagrama} para la partida del snake:

	\begin{figure}[H]
		\centering
		\includegraphics[height=1.2\textwidth]{disenio/flow.png}
		\caption{Diagrama de flujo juego snake}\label{fig:snakediagrama}
	\end{figure}

\section{Diseño arquitectónico}
La arquitectura de la aplicación ha seguido el el patrón de diseño BLoC~\cite{xurxodev:bloc}. Significa \emph{Business Logic Component}~\pageref{bloc}. Fue creado por Paolo Soare y Cong Hu, los dos de Google y presentado en la conferencia de Dart en 2018. Por lo que es algo bastante nuevo.

Para comprender el porque de esta arquitectura es necesario saber como funcionan los estados compartidos entre los componentes en los framework declarativos~\pageref{declarativo}.

\subsection{Framework declarativo}\label{declarativo}
Los framework declarativos son aquellos donde las vistas se crean y actualizan en base a los datos con los que la vista esta enlazada, de tal forma que, cuando estos datos cambian de valor, se actualizan con una nueva renderización. Es decir, cada uno de estos componentes tiene un estado.

Los frameworks declarativos más conocidos son: \emph{React.js. node.js, dart.js o Flutter}

En el caso de flutter, los componentes son conocidos como Widgets, y pueden tener 3 estados:

\begin{itemize}
	\item \textbf{Sin estado:} no guardan información.
	\item \textbf{Con estado local:} los datos son del widget como puede ser la posición del scroll.
	\item \textbf{Con estado global:} para compartir datos entre diferentes widgets. Como puede ser la sesión de usuario.
\end{itemize}

Un ejemplo de declaración de widget que tiene el estado dinámico~\ref{fig:estado}, para este caso extiende de \emph{statefulwidget}:
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{disenio/estado.png}
	\caption{Estado Flutter}\label{fig:estado}
\end{figure}

\subsection{BLoC}\label{bloc}
Este patrón lo que pretende es que los componentes sean intermediarios entre las vistas y el modelo. Esta basado en la programación reactiva, utilizando el patrón observer, en Flutter es llamado \emph{Streams} , lo dota de gran versatilidad.

Los objetivos cuando se presentó este patrón en la conferencia de Google eran tres:

\begin{itemize}
	\item \textbf{Centralizar la lógica de negocio:}
	\item \textbf{Centralizar los cambios de estados:}
	\item \textbf{Tener un mapa del formato de la vista:}
\end{itemize}


\section{Diseño de interfaces}\label{nterfaces }